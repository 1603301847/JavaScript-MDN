// 函数的声明
/**
 * 函数是 JavaScript 中的基本组件之一。 
 * 一个函数是 JavaScript 过程 — 一组执行任务或计算值的语句。
 * 要使用一个函数，你必须将其定义在你希望调用它的作用域内。
 * 一个JavaScript 函数用function关键字定义，后面跟着函数名和圆括号。
 */
/**
 * 定义函数
 * 函数声明
 * 一个函数定义（也称为函数声明，或函数语句）由一系列的function关键字组成，依次为：
 * 函数的名称。
 * 函数参数列表，包围在括号中并由逗号分隔。
 * 定义函数的 JavaScript 语句，用大括号{}括起来。
 */
// 定义一个简单的square函数
function square(number) {
    return number * number;
}
// 函数square使用了一个参数，叫作number。
// 这个函数只有一个语句，它说明该函数将函数的参数（即number）自乘后返回。
// 函数的return语句确定了函数的返回值： return number * number;

// 原始参数（比如一个具体的数字）被作为值传递给函数；
// 值被传递给函数，如果被调用函数改变了这个参数的值，这样的改变不会影响到全局或调用函数。



// 函数表达式
/**
 * 函数声明在语法上是一个语句，但函数也可以由函数表达式创建。
 * 这样的函数可以是匿名的；它不必有一个名称。
 */

// 函数square也可这样来定义
const square = function (number) { return number * number; };
var x = square(4); // 16

// 函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：
const factorial = function fac(n) { return n < 2 ? 1 : n * fac(n - 1) };
console.log(factorial(3)); // 6

// 当将函数作为参数传递给另一个函数时，函数表达式很方便。
// map的函数被定义，而后使用一个表达式函数作为其第一个参数进行调用：
function map(f, a) {
    let result = []; // 创建一个数组
    let i; // 声明一个值，用来循环
    for (i = 0; i != a.length; i++)
        result[i] = f(a[i]);
    return result;
}

// 在 JavaScript 中，可以根据条件来定义一个函数。
// 当 num 等于 0 的时候才会定义 myFunc
var myFunc;
if (num == 0) {
    myFunc = function (theObject) {
        theObject.make = "Toyoka"
    }
}



// 调用函数
/**
 * 定义一个函数并不会自动的执行它。
 * 定义了函数仅仅是赋予函数以名称并明确函数被调用时该做些什么。
 * 调用函数才会以给定的参数真正执行这些动作。
 */
// 定义square函数 使用 square(5);调用它。
// 通过提供参数 5 来调用函数。函数执行完它的语句会返回值25。
// 函数一定要处于调用它们的域中，但是函数的声明可以被提升(出现在调用语句之后)
console.log(square(5));
function square(n) { return n * n }

// 函数域是指函数声明时的所在的地方，或者函数在顶层被声明时指整个程序。
/**
 * 只有使用如上的语法形式（即 function funcName(){}）才可以。
 * 而下面的代码是无效的。就是说，函数提升仅适用于函数声明，而不适用于函数表达式。
 */
console.log(square); // square is hoisted with an initial value undefined.
console.log(square(5)); // Uncaught TypeError: square is not a function
const square = function (n) {
    return n * n;
}

// 函数可以被递归，就是说函数可以调用其本身



// 函数作用域
/**
 * 在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。
 * 相对应的，一个函数可以访问定义在其范围内的任何变量和函数。
 * 定义在全局域中的函数可以访问所有定义在全局域中的变量。
 * 在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量。
 */




// 作用域和函数堆栈
// 递归：一个函数可以指向并调用自身。
// 有三种方法： 1.函数名    2.arguments.callee  3. 作用域下的一个指向该函数的变量名
// 函数的定义
var foo = function bar() { }
// bar() arguments.callee() foo() 在这个函数体内，是等价的

// 调用自身的函数我们称之为递归函数。在某种意义上说，递归近似于循环。
// 两者都重复执行相同的代码，并且两者都需要一个终止条件（避免无限循环或者无限递归）。
var x = 0;
while (x < 10) { // "x < 10" 是循环条件
    x++;
}
// 可以被转化成一个递归函数和对其的调用：
function loop(x) {
    if (x >= 10)  // "x >= 10" 是退出条件（等同于 "!(x < 10)"）
        return;
    loop(x + 1); // 递归调用
}
loop(0);

// 有些算法并不能简单的用迭代来实现。
// 例如，获取树结构中所有的节点时，使用递归实现要容易得多：
function walkTree(node) {
    if (node == null)
        return;
    for (var i = 0; i < node.childNodes.length; i++) {
        walkTree(node.childNodes[i]);
    }
}
// 跟loop函数相比，这里每个递归调用都产生了更多的递归。



// 嵌套函数和闭包
/**
 * 你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。
 * 它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）。
 * 既然嵌套函数是一个闭包，就意味着一个嵌套函数可以"继承"容器函数的参数和变量。
 * 换句话说，内部函数包含外部函数的作用域。
 * 内部函数只可以在外部函数中访问
 * 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。
 */



// 保存变量
// 一个闭包必须保存它可见作用域中所有参数和变量。
// 因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包。



// 多层嵌套函数
/**
 * 函数可以被多层嵌套。
 * 例如，函数A可以包含函数B，函数B可以再包含函数C。
 * B和C都形成了闭包，所以B可以访问A，C可以访问B和A。
 * 因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域。
 * 这个称之为作用域链。
 */



// 命名冲突
/**
 *当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。
 更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。
 这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。
 */

// 闭包
/**
 * JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。
 * 外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。
 * 由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行时间长。
 * 当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。
 */

/**
 * 如果一个闭包的函数定义了一个和外部函数的某个变量名称相同的变量，那么这个闭包将无法引用外部函数的这个变量。
 */
var createPet = function (name) {
    return {
        setName: function (name) {
            name = name;
        }
    }
}



// 使用arguments对象
/**
 * 函数的实际参数会被保存在一个类似数组的arguments对象中。在函数内，你可以按如下方式找出传入的参数: arguments[i]
 * 其中i是参数的序数编号，以0开始。所以第一个传来的参数会是arguments[0]。参数的数量由arguments.length表示。
 */



// 函数参数
// 有两个新的类型的参数：默认参数，rest参数

/**
 * 默认参数
 * 在JavaScript中，函数参数的默认值是undefined。
 * 然而，在某些情况下设置不同的默认值是有用的。
 * 用于设定默认参数的一般策略是在函数的主体中测试参数值是否为undefined，如果是则赋予这个参数一个默认值。
 */

/**
 * rest参数
 * 允许将不确定数量的参数表示为数组
 */



// 箭头函数
/**
 * 相比函数表达式具有较短的语法并以词法的方式绑定this
 * 箭头函数总是匿名的。
 */